package com.mappinteligenceplugin

import android.util.Log
import androidx.annotation.IntRange
import androidx.core.net.toUri
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.module.annotations.ReactModule
import com.mappinteligenceplugin.mapper.CampaignParametersMapper
import com.mappinteligenceplugin.mapper.ECommerceParametersMapper
import com.mappinteligenceplugin.mapper.EventParametersMapper
import com.mappinteligenceplugin.mapper.ExceptionTypeMapper
import com.mappinteligenceplugin.mapper.MediaEventMapper
import com.mappinteligenceplugin.mapper.PageParametersMapper
import com.mappinteligenceplugin.mapper.SessionParametersMapper
import com.mappinteligenceplugin.mapper.UserCategoriesMapper
import com.mappinteligenceplugin.mapper.Util.toMap
import java.util.concurrent.TimeUnit
import webtrekk.android.sdk.Logger
import webtrekk.android.sdk.Webtrekk
import webtrekk.android.sdk.WebtrekkConfiguration
import webtrekk.android.sdk.events.ActionEvent
import webtrekk.android.sdk.events.PageViewEvent

@ReactModule(name = MappinteligencePluginModule.NAME)
class MappinteligencePluginModule(private val reactContext: ReactApplicationContext) :
  NativeMappintelligencePluginSpec(reactContext) {

  companion object {
    const val NAME = "MappinteligencePlugin"
    private val configAdapter: ConfigAdapter by lazy { ConfigAdapter() }
  }

  private var instance: Webtrekk? = null

  init {
    println("MappIntelligencePluginModule created!")
    println("MappIntelligence instance: $instance")
  }

  /**
   * Initialize native SDK with the provided trackIds and trackDomain and with the default other
   * parameters
   */
  @ReactMethod
  override fun initWithConfiguration(
    trackIds: ReadableArray,
    trackDomain: String,
    promise: Promise
  ) {
    val trackValues = mutableListOf<Double?>()
    for (i in 0 until trackIds.size()) {
      trackValues.add(trackIds.getDouble(i))
    }
    val ids = trackValues.mapNotNull { it?.toBigDecimal()?.toPlainString() }
    runOnPlugin(
      whenInitialized = { instance?.setIdsAndDomain(ids, trackDomain) },
      whenNotInitialized = {
        configAdapter.trackIds = ids
        configAdapter.trackDomain = trackDomain
      }
    )
    promise.resolve(true)
  }

  /**
   * Check if SDK is initialized and ready for usage Returns true if initialization was finished,
   * otherwise false
   */
  @ReactMethod
  override fun isInitialized(promise: Promise) {
    runOnPlugin(
      whenInitialized = { promise.resolve(true) },
      whenNotInitialized = { promise.resolve(false) }
    )
  }

  /**
   * Enable or disable anonymous tracking When anonymous tracking is enabled, everId will be deleted
   * and not created again while this value stays true
   */
  @ReactMethod
  override fun setAnonymousTracking(enabled: Boolean, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.anonymousTracking(enabled) },
      whenNotInitialized = { configAdapter.anonymousTracking = enabled }
    )
    promise.resolve(true)
  }

  /** Enable or disable sending appVersion parameter with a every request */
  @ReactMethod
  override fun setSendAppVersionInEveryRequest(enabled: Boolean, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.setVersionInEachRequest(enabled) },
      whenNotInitialized = { configAdapter.versionInEachRequest = enabled }
    )
    promise.resolve(true)
  }

  /**
   * Enable or disable user matching option User matching provides connection between users on
   * Engage and Intelligence systems
   */
  @ReactMethod
  override fun setEnableUserMatching(enabled: Boolean, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.setUserMatchingEnabled(enabled) },
      whenNotInitialized = { configAdapter.userMatchingEnabled = enabled }
    )
    promise.resolve(true)
  }

  /**
   * Set custom everId If null or empty string passed, everId will be autogenerated <b>It has effect
   * only if anonymous tracking is disabled</b>
   */
  @ReactMethod
  override fun setEverId(everId: String?, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.setEverId(everId) },
      whenNotInitialized = { configAdapter.everId = everId }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun getEverId(promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        val everId = instance?.getEverId()
        promise.resolve(everId)
      },
      whenNotInitialized = { promise.reject("", "SDK not initialized yet!") }
    )
  }

  @ReactMethod
  override fun setTemporarySessionId(sessionId: String?, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.setTemporarySessionId(sessionId ?: "") },
      whenNotInitialized = { configAdapter.temporarySessionId = sessionId ?: "" }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun optOut(sendData: Boolean, promise: Promise) {
    runOnPlugin(whenInitialized = { instance?.optOut(true, sendData) })
    promise.resolve(true)
  }

  @ReactMethod
  override fun optIn(sendData: Boolean, promise: Promise) {
    runOnPlugin(whenInitialized = { instance?.optOut(false, sendData) })
    promise.resolve(true)
  }

  @ReactMethod
  override fun setExceptionLogLevel(exceptionLevel: Double, promise: Promise) {
    val exceptionType = ExceptionTypeMapper(exceptionLevel).getData()
    runOnPlugin(
      whenInitialized = { instance?.setExceptionLogLevel(exceptionType) },
      whenNotInitialized = { configAdapter.exceptionLogLevel = exceptionType }
    )
    promise.resolve(true)
  }

  /**
   * Sets log level for a library. Disable or enable logs in the logcat from the intelligence SDK
   * and it's plugin
   */
  @ReactMethod
  override fun setLogLevel(level: Double, promise: Promise) {
    val levelInt = level.toInt()
    val nativeLevel =
      if (levelInt == 7) {
        Logger.Level.NONE
      } else {
        Logger.Level.BASIC
      }
    runOnPlugin(
      whenInitialized = { instance?.setLogLevel(nativeLevel) },
      whenNotInitialized = { configAdapter.logLevel = nativeLevel }
    )
    promise.resolve(true)
  }

  /**
   * Enable or disable sending requests in a batch When enabled, multiple track records are send via
   * single Http request
   */
  @ReactMethod
  override fun setBatchSupportEnabled(enabled: Boolean, promise: Promise) {
    runOnPlugin(
      whenInitialized = { instance?.setBatchEnabled(enabled) },
      whenNotInitialized = { configAdapter.batchSupport = enabled }
    )
    promise.resolve(true)
  }

  /**
   * Sets the number of records to be send in a single network request. Value must be in the defined
   * range for size
   */
  @ReactMethod
  override fun setBatchSupportSize(size: Double, promise: Promise) {
    val sizeInt = size.toInt()
    runOnPlugin(
      whenInitialized = { instance?.setRequestPerBatch(sizeInt) },
      whenNotInitialized = { configAdapter.requestPerBatch = sizeInt }
    )
    promise.resolve(true)
  }

  /**
   * Sets time interval, in minutes, for a job of automatic sending of the tracking records Minimum
   * value is 15 minutes, limited by Android OS.
   */
  @ReactMethod
  override fun setRequestInterval(interval: Double, promise: Promise) {
    val intervalInt = interval.toInt()
    runOnPlugin(
      whenInitialized = { instance?.setRequestInterval(intervalInt.toLong()) },
      whenNotInitialized = { configAdapter.requestsIntervalMinutes = intervalInt }
    )
    promise.resolve(true)
  }

  /** This operation is not supported on android Method exists only for compatibility */
  @ReactMethod
  override fun setRequestPerQueue(queue: Double, promise: Promise) {
    promise.resolve(true)
  }

  /**
   * Enable or disable migration from previous version of a native SDK React Native plugin was not
   * developed with a older version (v4) of the native plugin, so migration for this plugin will
   * always stay false.
   */
  @ReactMethod
  override fun setShouldMigrate(migrate: Boolean, promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        if (migrate) {
          reset { it.enableMigration() }
        }
      },
      whenNotInitialized = { configAdapter.shouldMigrate = migrate }
    )
    promise.resolve(true)
  }

  /** Required only for iOS; Method just returns success and exist only for compatibility */
  @ReactMethod
  override fun setEnableBackgroundSendout(enabled: Boolean, promise: Promise) {
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackCustomPage(
    pageTitle: String?,
    pageParams: ReadableMap,
    sessionParams: ReadableMap,
    userCategoryParams: ReadableMap,
    ecommerceParams: ReadableMap,
    campaignParams: ReadableMap,
    promise: Promise
  ) {
    runOnPlugin(
      whenInitialized = {
        val page = PageParametersMapper(pageParams).getData()
        val session = SessionParametersMapper(sessionParams).getData()
        val userCat = UserCategoriesMapper(userCategoryParams).getData()
        val ecommerce = ECommerceParametersMapper(ecommerceParams).getData()
        val campaign = CampaignParametersMapper(campaignParams).getData()

        val pageViewEvent =
          PageViewEvent(pageTitle ?: "NO_NAME_PAGE").apply {
            this.pageParameters = page
            this.sessionParameters = session
            this.userCategories = userCat
            this.eCommerceParameters = ecommerce
            this.campaignParameters = campaign
          }
        instance?.trackPage(pageViewEvent)
      }
    )
    promise.resolve(true)
  }

  /** Track page with a provided [PageViewEvent] */
  @ReactMethod
  override fun trackPageWithCustomData(params: ReadableMap, pageTitle: String, promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        instance?.trackCustomPage(pageTitle, params.toMap(keyTransform = { it.toString() }))
      }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackPage(pageTitle: String, promise: Promise) {
    runOnPlugin(whenInitialized = { instance?.trackPage(PageViewEvent(pageTitle)) })
    promise.resolve(true)
  }

  @ReactMethod
  override fun sendRequestsAndClean(promise: Promise) {
    runOnPlugin(whenInitialized = { instance?.sendRequestsNowAndClean() })
    promise.resolve(true)
  }


  @ReactMethod
  override fun trackAction(
    name: String,
    eventParameters: ReadableMap,
    sessionParameters: ReadableMap,
    userCategories: ReadableMap,
    eCommerceParameters: ReadableMap,
    campaignParameters: ReadableMap,
    promise: Promise
  ) {
    runOnPlugin(
      whenInitialized = {
        val event = EventParametersMapper(eventParameters).getData()
        val session = SessionParametersMapper(sessionParameters).getData()
        val userCat = UserCategoriesMapper(userCategories).getData()
        val ecommerce = ECommerceParametersMapper(eCommerceParameters).getData()
        val campaignParams = CampaignParametersMapper(campaignParameters).getData()
        val actionEvent =
          ActionEvent(name).apply {
            this.eventParameters = event
            this.sessionParameters = session
            this.userCategories = userCat
            this.eCommerceParameters = ecommerce
            this.campaignParameters = campaignParams
          }
        instance?.trackAction(actionEvent)
      }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackException(
    name: String,
    message: String,
    stacktrace: String?,
    promise: Promise
  ) {
    runOnPlugin(
      whenInitialized = {
        if (stacktrace.isNullOrEmpty()) {
          instance?.trackException(name, message)
        } else {
          instance?.trackException(name, message + "\n${stacktrace}")
        }
      }
    )
    promise.resolve(true)
  }

  @ReactMethod
  fun trackException(exception: ReadableMap, promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        val innerException = Exception(exception.getString("message"))
        instance?.trackException(innerException)
      }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackMedia(readableMap: ReadableMap, promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        MediaEventMapper(readableMap).getData()?.let { instance?.trackMedia(it) }
      }
    )
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackUrl(url: String, mediaCode: String?, promise: Promise) {
    runOnPlugin(whenInitialized = { instance?.trackUrl(url.toUri(), mediaCode) })
    promise.resolve(true)
  }

  @ReactMethod
  override fun trackExceptionWithName(
    name: String,
    message: String,
    stacktrace: String?,
    promise: Promise
  ) {
    runOnPlugin(
      whenInitialized = {
        Log.d("MappIntelligencePlugin", "trackExceptionWithName")
        if (stacktrace.isNullOrEmpty()) {
          instance?.trackException(name, message)
        } else {
          instance?.trackException(name, message + "\n${stacktrace}")
        }
      }
    )
    promise.resolve(true)
  }

  /** Configure webtrekk SDK and initialize it */
  @ReactMethod
  override fun build(promise: Promise) {
    runOnPlugin(
      whenNotInitialized = {
        val builder =
          WebtrekkConfiguration.Builder(
            configAdapter.trackIds,
            configAdapter.trackDomain
          )
            .logLevel(configAdapter.logLevel)
            .enableCrashTracking(configAdapter.exceptionLogLevel)
            .setBatchSupport(
              configAdapter.batchSupport,
              configAdapter.requestPerBatch
            )
            .requestsInterval(
              TimeUnit.MINUTES,
              configAdapter.requestsIntervalMinutes.toLong()
            )
            .setEverId(configAdapter.everId)
            .sendAppVersionInEveryRequest(configAdapter.versionInEachRequest)

        if (configAdapter.shouldMigrate) builder.enableMigration()

        if (!configAdapter.autoTracking) builder.disableAutoTracking()

        if (!configAdapter.activityAutoTracking) builder.disableActivityAutoTracking()

        if (!configAdapter.fragmentsAutoTracking) builder.disableFragmentsAutoTracking()

        instance =
          Webtrekk.getInstance().apply {
            this.init(reactContext.applicationContext, builder.build())
            this.anonymousTracking(configAdapter.anonymousTracking)
            this.setTemporarySessionId(configAdapter.temporarySessionId)
          }
        promise.resolve(true)
        println("MappIntelligence initialized!")
      },
      whenInitialized = {
        promise.resolve(true)
        println("MappIntelligence was already initialized!")
      }
    )
  }

  /**
   * Helper function to execute actions based on Webtrekk instance state Provide two functions as
   * input parameters to be executed if instance is initialized or not
   */
  private fun runOnPlugin(whenInitialized: () -> Unit, whenNotInitialized: (() -> Unit)? = null) {
    if (instance != null) {
      whenInitialized.invoke()
    } else {
      whenNotInitialized?.invoke()
    }
  }

  @ReactMethod
  override fun reset(promise: Promise) {
    runOnPlugin(whenInitialized = { reset {} })
    promise.resolve(true)
  }

  /**
   * Reset underlying SDK and set new values via
   * @param presetAction
   * - action that has access to WebtrekkConfiguration Builder to change existing configuration and
   * set new values
   */
  private fun reset(presetAction: (WebtrekkConfiguration.Builder) -> Unit) {
    Webtrekk.reset(reactContext.applicationContext)
    val trackIds = configAdapter.trackIds
    val domain = configAdapter.trackDomain

    instance?.setIdsAndDomain(trackIds, domain)
  }

  @ReactMethod
  override fun getCurrentConfig(promise: Promise) {
    runOnPlugin(
      whenInitialized = {
        val config = instance?.getCurrentConfiguration()
        promise.resolve(config?.toString() ?: "")
      },
      whenNotInitialized = { promise.resolve("") }
    )
  }

  @ReactMethod
  override fun nativeCrash(promise: Promise) {
    throw Exception("Native crash")
  }

  @ReactMethod
  fun nativeCrash() {
    throw Exception("Native crash");
  }

  override fun getName(): String {
    return NAME
  }

  override fun initialize() {}

  override fun invalidate() {}
}
